# Snowflake Native App Framework & Examples â€“ A Blueprint for SnowSarva

Source:
*   <https://github.com/snowflakedb/native-apps-examples>
*   <https://github.com/Snowflake-Labs/sfguide-getting-started-with-native-apps>
*   <https://github.com/Snowflake-Labs/sfguide-native-apps-chairlift>

The Snowflake Native App Framework allows developers to build, distribute, and monetize applications directly on the Snowflake Marketplace. These applications run entirely inside the consumer's Snowflake account, ensuring data never leaves their security perimeter. This is the core deployment model for SnowSarva.

---

## 1. Key Architectural Components

A Snowflake Native App is defined by a set of core files that instruct Snowflake on how to install, configure, and run the application.

*   `manifest.yml`: **The Application's Constitution.** This YAML file is the most important component. It declares:
    *   The application `name`, `version`, and `label`.
    *   The `setup_script` to be run upon installation.
    *   A list of `artifacts` to be included in the package, such as source code files for procedures and UIs.
    *   `references` to objects the application needs access to (e.g., `SNOWFLAKE.ACCOUNT_USAGE`). The consumer must explicitly grant these permissions upon installation.
    *   Configuration for `container_services` if the app uses them.

*   `setup.sql`: **The Installation Script.** This SQL script is executed once when a consumer installs or upgrades the application. Its primary responsibilities are:
    *   Creating the `APPLICATION ROLE` (e.g., `SNOWSARVA_APP_ROLE`). This is a critical security practice, as consumers grant privileges *to this role*, not to the underlying app objects, giving them full control.
    *   Creating the application's internal schemas and tables.
    *   Creating user-facing objects like `STREAMLIT` UIs, stored procedures, and UDFs.
    *   Granting permissions on the app's objects to the `APPLICATION ROLE`.

*   **Application Code & Logic**:
    *   This includes the Python/Java/Scala source files for stored procedures, UDFs, and tasks.
    *   For UIs, it includes the main Python file for a `STREAMLIT` application.
    *   For containerized services, it includes the Docker image specification and the application code (e.g., a FastAPI server) that runs inside the container.

*   `environment.yml`: **Dependency Management.** Defines the Python packages (e.g., `pandas`, `scikit-learn`) required by the application's Snowpark code, which Snowflake will install into a secure Conda environment.

---

## 2. Architectural Implications & Best Practices for SnowSarva

The official examples provide a clear, prescriptive path for packaging and deploying SnowSarva.

*   **Packaging Strategy:**
    *   **Action**: The entire SnowSarva application will be bundled into a single package using the `snow` CLI (`snow app run`). The structure will mirror the examples, with a top-level `manifest.yml`, a `src/` directory for Python code, and a `scripts/` directory for the `setup.sql`.
    *   **Action**: The `setup.sql` script must be idempotent, meaning it can be re-run without causing errors. This is crucial for seamless upgrades.

*   **Security Model:**
    *   **Goal**: Adhere strictly to the principle of least privilege.
    *   **Action**: The `setup.sql` will create a `SNOWSARVA_APP_ROLE`. The manifest will declare all required privileges (e.g., `USAGE` on `SNOWFLAKE.ACCOUNT_USAGE` views), which the consumer must approve and grant to this role. SnowSarva will never ask for `ACCOUNTADMIN` or other high-level roles.
    *   **Action**: All data generated by SnowSarva (cost reports, quality metrics, etc.) will be stored in a dedicated schema within the consumer's account, giving them full ownership and control.

*   **UI & Interactivity:**
    *   **Goal**: Provide a seamless user experience within Snowsight.
    *   **Action**: The main SnowSarva dashboard will be a `STREAMLIT` application, created in the `setup.sql`. This allows for a rich, interactive UI without requiring any external hosting.
    *   **Action**: For more complex, client-side interactions (like the interactive lineage graph), a React-based frontend will be built, compiled, and served from the Streamlit component, or hosted in SPCS.

*   **Deployment and Upgrades:**
    *   **Goal**: Ensure smooth, reliable upgrades for consumers.
    *   **Action**: Utilize `VERSIONED SCHEMAS` during development to test upgrade paths. The `setup.sql` will handle any necessary schema migrations between versions.
    *   **Action**: Distribute SnowSarva via the Snowflake Marketplace, using private listings for early-access customers and public listings for general availability. This manages the entire installation and billing lifecycle.

By following these established patterns, SnowSarva can be delivered as a secure, robust, and enterprise-grade application that feels like a natural extension of the Snowflake platform itself. 